#!/usr/bin/env python

import argparse
import configparser
import os
import subprocess as sp

from PyInquirer import print_json, prompt

# load the configuration
config = configparser.ConfigParser()
config.read('config.ini')

DEFAULT_CAP = os.path.abspath(os.path.join(
    config['PROJECT']['BUILD_DIR'],
    'com.baload-jc212.cap',
))


parser = argparse.ArgumentParser(
    description='Test non-interactive scenarios'
)

parser.add_argument('-i', '--interactive', action='store_true')
parser.add_argument(
        '-c', '--cap',
        default=DEFAULT_CAP,
     )

args = parser.parse_args()
cap_file = args.cap


gp = [
    'java',
    '-jar',
    os.path.join(os.environ['HOME'], 'projects/GlobalPlatformPro/gp.jar'),
]

def run_command(cmd):
    process = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE)
    while process.poll() is None:
        output = process.stdout.readline().decode('utf8')
        if output:
            print(output, end='')
    rc = process.poll()
    print(rc)

def install():
    cmd = gp + [
        '--verbose',
        '--debug',
        '--install',
        cap_file
    ]
    # output = sp.check_output(cmd)
    run_command(cmd)

def uninstall():
    cmd = gp + [
        '--verbose',
        '--debug',
        '--uninstall',
        cap_file
    ]
    # output = sp.check_output(cmd)
    run_command(cmd)

def create_select_apdu():
    aid = config['DEFAULT']['AID']
    select_payload = '00a40400'
    select_payload += '{:02}'.format(len(aid)//2)
    select_payload += aid
    return select_payload

def select():
    cmd = gp + [
        '--verbose',
        '--debug',
        '--apdu',
        create_select_apdu(),
    ]
    # output = sp.check_output(cmd)
    run_command(cmd)

def validate_index(value):
    start = None
    end = None
    # handle if the input is an integer range
    try:
        start, end = [int(x) for x in value.split()]
    except ValueError:
        # apparently the index is not an integer range 'X Y'
        pass
    # handle if the input is a hexadecimal range
    try:
        start, end = [int(x, 16) for x in value.split()]
    except ValueError:
        # apparently the index is not an hexadecimalrange 'X Y'
        pass

    # handle all possible invalid integer values
    if start is not None:
        if start < end:
            return start, end
        else:
            raise ValueError('Invalid range: {} !< {}'.format(start, end))

    # handle if the input is an integer value
    try:
        return int(value), None
    except ValueError:
        # value is not a range or a single index
        pass

        # handle if the input is a hexadecimal value
    try:
        return int(value, 16), None
    except ValueError:
        # value is not a range or a single index
        pass

    return value, None

def create_ins_read_apdu(index):
        return 'a004' + '{:04X}'.format(index) + '00'

# def handle_index_q(answer, on_end)
#     # 'q' for quit
#     if type(start) == str:
#         break

#     if end is not None:
#         for index in range(start, end):
#             cmd[-1] = create_select_apdu(index)
#             run_command(cmd)
#     else:
#         cmd[-1] = create_select_apdu(index)
#         run_command(cmd)

def ins_read():
    cmd = gp + [
        '--verbose',
        '--debug',
        '--apdu',
        create_select_apdu(),
    ]
    cmd += [
        '--apdu',
        'a004000000',
    ]

    cont_q = {
            'type': 'confirm',
            'message': 'Run in continuous mode?',
            'name': 'continuous',
        }
    index_q = {
        'type': 'input',
        'message': 'Give me an index P1P2 (or a range [0 - FFFF])',
        'name': 'index',
    }

    answer = prompt(cont_q)
    if answer['continuous']:
        while True:
            answer = prompt(index_q)
            start, end = validate_index(answer['index'])

            # 'q' for quit
            if type(start) == str:
                break

            if end is not None:
                for index in range(start, end):
                    cmd[-1] = create_ins_read_apdu(index)
                    run_command(cmd)
            else:
                cmd[-1] = create_ins_read_apdu(start)
                run_command(cmd)
    else:
        answer = prompt(index_q)
        start, end = validate_index(answer['index'])

        if type(start) == str:
            return

        if end is not None:
            for index in range(start, end):
                cmd[-1] = create_ins_read_apdu(index)
                run_command(cmd)
        else:
            cmd[-1] = create_ins_read_apdu(start)
            run_command(cmd)

INSTALL = 'install'
SELECT = 'select'
INS_READ = 'ins_read'
UNINSTALL = 'uninstall'

STEPS = {
    INSTALL: install,
    SELECT: select,
    INS_READ: ins_read,
    UNINSTALL: uninstall,
}

step_qs = [
    {
        'type': 'list',
        'message': 'Which step do you want to perform?',
        'name': 'step',
        'choices': list(STEPS.keys()) + ['exit'],
        },
]


def main():
    if args.interactive:
        answer = prompt(step_qs)
        while True:
            if answer['step'] == 'exit':
                break
            STEPS[answer['step']]()

            answer = prompt(step_qs)
    else:
        for step, func in STEPS.items():
            print(step)
            func()

if __name__ == '__main__':
    main()
