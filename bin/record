#!/usr/bin/env python3
import argparse
import hashlib
import logging
import os
import re
import subprocess as sp
import sys
import time
from datetime import datetime, timezone

import pkcs11
import pymongo

log = logging.getLogger(__file__)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(levelname)s:%(asctime)s:%(name)s: %(message)s')
handler.setFormatter(formatter)
log.addHandler(handler)
LOG_LEVELS = [
    logging.DEBUG, logging.INFO, logging.WARNING,
    logging.ERROR, logging.CRITICAL
]

# kudos to: https://medium.com/@ramojol/python-context-managers-and-the-with-statement-8f53d4d9f87
class MongoConnection(object):
    def __init__(self, host='localhost', port='27017'):
        self.host = host
        self.port = port
        self.connection = None
        self.db_name = 'card-analysis'
        self.collation_name = 'commands'

    def __enter__(self, *args, **kwargs):
        conn_str = f'mongodb://{self.host}:{self.port}'
        log.debug('Starting the connection with %s', conn_str)

        self.connection = pymongo.MongoClient(conn_str)
        self.db = self.connection[self.db_name]
        self.col = self.db[self.collation_name]
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        log.debug('Closing the connection to the database')
        self.connection.close()

class Timer(object):
    # naive timer, but to get at least an idea
    def __init__(self):
        self.start = None
        self.end = None
        self.duration = None

    def __enter__(self, *args, **kwargs):
        self.start = time.time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = time.time()
        self.duration = self.end - self.start


def determine_reader():
    # hardcoded for now some cards are not recognized
    return 'Gemalto PC Twin Reader 00 00'
    return 'Alcor Micro AU9560 00 00'

    lib = pkcs11.lib('/usr/lib/x86_64-linux-gnu/pkcs11/opensc-pkcs11.so')
    try:
        log.debug('Getting the card reader slots')
        slots = lib.get_slots()
    except pkcs11.DeviceError:
        log.error('determine_reader failed with DeviceError')

    tokens = []
    devices = []
    for slot in slots:
        if slot.flags & pkcs11.SlotFlag.TOKEN_PRESENT:
            tokens.append(slot.slot_description)

    if len(tokens) > 1:
        msg = 'Multiple tokens detected!'
        raise RuntimeError(msg)
    elif len(tokens) == 1:
        return tokens[0]

    msg = 'No tokens present in any of the readers. Readers found:\n'
    msg += '\n'.join([slot.slot_description for slot in slots])
    raise RuntimeError(msg)

def get_utc_timestamp():
    now = datetime.now()
    now = now.replace(tzinfo=timezone.utc)
    return now.timestamp()

def insert_middle(original, position, values):
    # will remove the value in original[position]
    return original[:position] + values + original[position + 1:]

def md5_file(filename):
    # kudos to:
    # https://stackoverflow.com/a/3431838/2377489
    md5 = hashlib.md5()
    with open(filename, 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b''):
            md5.update(chunk)
    return md5.hexdigest()

def uses_capfile(command):
    cap_mask = [x.endswith('.cap') for x in command]
    try:
        return any(cap_mask), cap_mask.index(True)
    except ValueError:
        return any(cap_mask), None

class Recorder(object):
    def __init__(self):
        self.verbosity = logging.ERROR
        self.dry_run = False
        self.command = None
        self.record = True
        self.gp = [
            'java',
            '-jar',
            os.path.join(os.environ['HOME'], 'projects/GlobalPlatformPro/gp.jar'),
        ]

        self.parser = argparse.ArgumentParser(
                description="Run a command and record it's output in a MongDB"
        )
        self.add_options()
        self.parse_options()

        log.setLevel(self.verbosity)
        log.debug('Logging level changed')

    def add_options(self):
        levels = ', '.join([str(lvl) for lvl in LOG_LEVELS])
        self.parser.add_argument(
            '-v', '--verbose',
            help='Set the verbosity {' + levels + '}',
            type=self.validate_verbosity,
        )
        self.parser.add_argument(
            '-n', '--dry-run',
            help='Don\'t run any command and don\'t save the output into db',
            action='store_true',
        )
        self.parser.add_argument(
            '-s', '--no-record',
            help='Don\'t record the command output in the database',
            action='store_false'
        )

        self.parser.add_argument(
            '-c', '--comment',
            help='Add a comment',
        )

        self.parser.add_argument(
            'command', nargs='*',
            )

        self.parser.add_argument(
            '-a', '--name',
            help='Card name',
            type=lambda x: x in 'ABCDEFGHI',
            required=True,
        )

    def validate_verbosity(self, value):
        try:
            value = int(value)
        except ValueError:
            raise argparse.ArgumentTypeError('verbosity is not and integer')
        if value not in LOG_LEVELS:
            raise argparse.ArgumentTypeError('verbosity level not from expected range')
        return value

    def parse_options(self):
        args = self.parser.parse_args()
        if args.verbose is not None:
            self.verbosity = args.verbose
        self.dry_run = args.dry_run
        self.command = args.command

        if args.comment is not None:
            self.comment = args.comment
        else:
            self.comment = ''

        if not self.command:
            raise argparse.ArgumentTypeError("positional argument 'command' required")

        if not args.no_record:
            self.record = False

        self.name = args.name

    def substitute_gp(self):
        if 'gp' in self.command:
            self.command = insert_middle(self.command, self.command.index('gp'), self.gp)

    def get_card_name(self):
        cmd = self.gp[:]
        if '--emv' in self.command:
            cmd += ['--emv']

        cmd += ['--info']
        output = sp.check_output(cmd)

        atr = re.compile(r'ATR: ([0-9A-Z]+)')
        groups = atr.search(output.decode('utf8'))
        if groups:
            ATR = groups.group(1)
        else:
            return ''

        name = sp.check_output(['id-card', ATR])
        return name.decode('utf8').strip()


    def run(self):
        reader = determine_reader()
        timestamp = get_utc_timestamp()
        # resolve gp alias
        self.substitute_gp()
        record = {}

        if self.dry_run:
            print('Would run:')
            print(self.command)
            sys.exit(0)


        with Timer() as timer:
            process = sp.run(self.command,
                    stdout=sp.PIPE,
                    stderr=sp.PIPE,
            )

        # card_name = self.get_card_name()
        card_name = self.name
        has_cap, index = uses_capfile(self.command)
        cap_record = {
            'cap-file': '',
            'cap-file-md5sum': '',
        }
        if has_cap:
            file_sum = md5_file(self.command[index])
            cap_record['cap-file'] = self.command[index]
            cap_record['cap-file-md5sum'] = file_sum

        record.update(cap_record)


        stdout = process.stdout.decode('utf8')
        stderr = process.stderr.decode('utf8')
        print('standard output:')
        print(stdout)
        print('standard error:')
        print(stderr)

        if self.record:
            log.info('Output recording')
            record.update({
                'comment': self.comment,
                'command': ' '.join(self.command),
                'stdout': stdout,
                'stderr': stderr,
                'returncode': process.returncode,
                'timestamp': timestamp,
                'duration': timer.duration,
                'card-name': card_name,
                'reader': reader,
            })
            with MongoConnection() as c:
                c.col.insert_one(record)
        else:
            log.info('Not recording of the output')

if __name__ == '__main__':
    recorder = Recorder()
    recorder.run()
