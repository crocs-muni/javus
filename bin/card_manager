#!/usr/bin/env python
import argparse
import logging
import sys

import smartcard
from jcvmutils.utils import CommandLineApp
from smartcard.CardConnection import CardConnection
from smartcard.System import readers
from smartcard.util import toHexString

log = logging.getLogger(__file__)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(levelname)s:%(asctime)s:%(name)s: %(message)s')
handler.setFormatter(formatter)
log.addHandler(handler)

LOG_LEVELS = [
    logging.DEBUG, logging.INFO, logging.WARNING,
    logging.ERROR, logging.CRITICAL
]
SELECT = [0x00, 0xA4, 0x04, 0x00]

CARD_NAME_APPLET_AID = [0x00, 0x11, 0x22, 0x33, 0x44, 0xAA, 0xBB, 0xCC]
LEN_AID = [len(CARD_NAME_APPLET_AID)]

GET_NAME_APDU = [0xA0, 0x08, 0x00, 0x00, 0x01]

SET_NAME_APDU = [0xA0, 0x04, 0x00, 0x00]


class CardManager(CommandLineApp):
    NO_CARDS_DETECTED_ERROR = 1
    TOO_MANY_CARDS_DETECTED_ERROR = 2
    def __init__(self):
        self.card = None
        self.new_card_name = None
        self.protocol = None
        super().__init__()

        self.readers = readers()
        log.setLevel(self.verbosity)

        self.detect_card()

    def add_options(self):
        super().add_options()
        self.parser.add_argument(
            '-a', '--new-card-name',
            help='Provide at most 256 bytes',
            type=self.validate_name,
        )

    def parse_options(self):
        super().parse_options()
        if self.args.new_card_name is not None:
            self.new_card_name = self.args.new_card_name

    def validate_name(self, value):
        '''Expects value to be 'ascii' string
        '''
        if len(value) > 256:
            raise argparse.ArgumentTypeError("The name '{}' is too long".format(value))
        try:
            return list(bytes(value, 'ascii'))
        except UnicodeDecodeError:
            raise argparse.ArgumentTypeError("The name '{}' contains non-ascii characters".format(value))

    def clean_name(self, value):
        return bytes.fromhex(value)

    def detect_card(self):
        cards = []
        for reader in self.readers:
            con = reader.createConnection()
            try:
                con.connect()
                cards.append(con)
            except smartcard.Exceptions.NoCardException:
                continue

        if len(cards) < 1:
            log.error('No cards have been detected! Try inserting one.')
            sys.exit(self.NO_CARDS_DETECTED_ERROR)

        if len(cards) > 1:
            log.error('Too many cards have been detected! Insert only one.')
            sys.exit(self.TOO_MANY_CARDS_DETECTED_ERROR)

        self.card = cards[0]

    def detect_protocol(self):
        atr = self.card.getATR()

        log.debug('Determing supported protocol from ATR.')
        if atr.isT0Supported():
            log.debug('T0 protocol is used.')
            self.protocol = CardConnection.T0_protocol
            return

        if atr.isT1Supported():
            log.debug('T1 protocol is used.')
            self.protocol = CardConnection.T1_protocol
            return

        if atr.isT15Supported():
            log.debug('T15 protocol is used.')
            self.protocol = CardConnection.T15_protocol
            return

        raise RuntimeError('No protocol supported!')

    def install_card_name_applet(self):
        pass

    def format_sws(self, *sws):
        error_code = ''.join(['{:02X}'.format(x) for x in sws])
        return error_code

    def select_card_name_applet(self):
        log.info('Selecting the card-name applet')
        data, sw1, sw2 = self.card.transmit(
            bytes=SELECT + LEN_AID + CARD_NAME_APPLET_AID,
            protocol=self.protocol)
        log.info('Receieved data: {data} and code {code}'.format(
            data=data, code=self.format_sws(sw1, sw2))
        )

    def get_card_name(self):
        self.select_card_name_applet()

        log.info('Getting the card-name')
        data, sw1, sw2 = self.card.transmit(
            bytes=GET_NAME_APDU,
            protocol=self.protocol)
        log.info('Receieved data: {data} and code {code}'.format(
            data=data, code=self.format_sws(sw1, sw2))
        )
        if data:
            print('card-name: ' + ''.join([chr(x) for x in data]))
        else:
            print('No card name retrieved.')

    def set_card_name(self):
        log.info("Setting new name of the card to '{}'".format(self.new_card_name))
        if self.new_card_name is None:
            raise ValueError('No new card name was set.')

        self.select_card_name_applet()
        payload = SET_NAME_APDU
        payload.append(len(self.new_card_name))
        payload.extend(self.new_card_name)
        data, sw1, sw2 = self.card.transmit(
            bytes=payload,
            protocol=self.protocol)

    def run(self):
        if self.new_card_name is not None:
            self.set_card_name()
        else:
            self.get_card_name()


if __name__ == '__main__':
    card_manager = CardManager()
    card_manager.run()
