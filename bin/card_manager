#!/usr/bin/env python
import argparse
import logging
import sys

import smartcard
from smartcard.CardConnection import CardConnection
from smartcard.System import readers
from smartcard.util import toHexString

from jcvmutils.functions import is_hex
from jcvmutils.utils import CommandLineApp

log = logging.getLogger(__file__)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(levelname)s:%(asctime)s:%(name)s: %(message)s')
handler.setFormatter(formatter)
log.addHandler(handler)

LOG_LEVELS = [
    logging.DEBUG, logging.INFO, logging.WARNING,
    logging.ERROR, logging.CRITICAL
]
# r = readers()
# con = r[0].createConnection()
# con.connect()

# SELECT = [0x00, 0xa4, 0x04, 0x00]
# LC = [0x08]
# AID = [0x00, 0x11, 0x22, 0x33, 0x44, 0xAA, 0xBB, 0xCC]

# data, sw1, sw2 = con.transmit(SELECT + LC + AID, protocol=CardConnection.T1_protocol)
# print(data, sw1, sw2)

# GET_NAME = [0xa0, 0x08, 0x00, 0x00, 0x00]
# data,sw1, sw2 = con.transmit(GET_NAME, protocol=CardConnection.T1_protocol)
# print(data, sw1, sw2)
SELECT = [0x00, 0xA4, 0x04, 0x00]

CARD_NAME_APPLET_AID = [0x00, 0x11, 0x22, 0x33, 0x44, 0xAA, 0xBB, 0xCC]
# 00a40400080011223344AABBCC
LEN_AID = [len(CARD_NAME_APPLET_AID)]

GET_NAME_APDU = [0xA0, 0x08, 0x00, 0x00, 0x00]

SET_NAME_APDU = [0xA0, 0x04, 0x00, 0x00]


class CardManager(CommandLineApp):
    NO_CARDS_DETECTED_ERROR = 1
    TOO_MANY_CARDS_DETECTED_ERROR = 2
    def __init__(self):
        self.card = None
        self.new_card_name = None
        super().__init__()
        self.readers = readers()
        # self.cards = None
        log.setLevel(self.verbosity)

        self.detect_card()

    def add_options(self):
        super().add_options()
        self.parser.add_argument(
            '-a', '--new-card-name',
            help='Provide at most 256 bytes',
            type=self.validate_name,
        )

    def parse_options(self):
        super().parse_options()
        if self.args.new_card_name is not None:
            self.new_card_name = self.args.new_card_name

    def validate_name(self, value):
        '''Expects value to be 'ascii' string
        '''
        if len(value) > 256:
            raise argparse.ArgumentTypeError("The name '{}' is too long".format(value))
        try:
            return list(bytes(value, 'ascii'))
        except UnicodeDecodeError:
            raise argparse.ArgumentTypeError("The name '{}' contains non-ascii characters".format(value))
        # if not is_hex(value):
        #     raise argparse.ArgumentTypeError("The name '{}' is not a hexadecimal string".format
        #             (value))
        # return self.clean_name(value)

    def clean_name(self, value):
        # value = value.upper()
        # if len(value) % 2 != 0:
        #     value = '0' + value
        # if len(value) / 2 > 256:
        #     value = value[:256]

        # return value.decode('hex')
        return bytes.fromhex(value)

    def detect_card(self):
        cards = []
        for reader in self.readers:
            con = reader.createConnection()
            try:
                con.connect()
                cards.append(con)
            except smartcard.Exceptions.NoCardException:
                continue

        if len(cards) < 1:
            log.error('No cards have been detected! Try inserting one.')
            sys.exit(self.NO_CARDS_DETECTED_ERROR)

        if len(cards) > 1:
            log.error('Too many cards have been detected! Insert only one.')
            sys.exit(self.TOO_MANY_CARDS_DETECTED_ERROR)

        self.card = cards[0]

    def install_card_name_applet(self):
        pass

    def format_sws(self, *sws):
        error_code = ''.join(['{:02X}'.format(x) for x in sws])
        return error_code

    def select_card_name_applet(self):
        log.info('Selecting the card-name applet')
        data, sw1, sw2 = self.card.transmit(SELECT + LEN_AID + CARD_NAME_APPLET_AID)
        log.info('Receieved data: {data} and code {code}'.format(
            data=data, code=self.format_sws(sw1, sw2))
        )

    def get_card_name(self):
        self.select_card_name_applet()

        log.info('Getting the card-name')
        data, sw1, sw2 = self.card.transmit(GET_NAME_APDU)
        log.info('Receieved data: {data} and code {code}'.format(
            data=data, code=self.format_sws(sw1, sw2))
        )
        if data:
            print('card-name: ' + ''.join([chr(x) for x in data]))
        else:
            print('No card name retrieved.')

    def set_card_name(self):
        log.info("Setting new name of the card to '{}'".format(self.new_card_name))
        if self.new_card_name is None:
            raise ValueError('No new card name was set.')

        self.select_card_name_applet()
        payload = SET_NAME_APDU
        payload.append(len(self.new_card_name))
        payload.extend(self.new_card_name)
        # payload = SET_NAME_APDU.extend([len(self.new_card_name)] + self.new_card_name)
        data, sw1, sw2 = self.card.transmit(payload)

    def run(self):
        if self.new_card_name is not None:
            self.set_card_name()
        else:
            self.get_card_name()


if __name__ == '__main__':
    card_manager = CardManager()
    card_manager.run()
